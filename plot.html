<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 US States with Region Colors and Tooltips</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            overflow: hidden; /* Prevent overflow */
        }
        #svg-container {
            max-width: 100%;
            width: 100%;  /* Full width */
            height: 100%; /* Full height */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden; /* Prevent overflow */
        }

        svg {
            width: 100%;
            height: 100%;
        }
        .tooltip {
            position: absolute;
            background-color: white;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            pointer-events: none;
            font-family: sans-serif;
            font-size: 14px;
            color: #333;
            box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.2s;
        }
    </style>
</head>
<body>

    <div id="svg-container">
        <svg id="main-svg"></svg>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        const svgContainer = document.getElementById("svg-container");
        const svg = d3.select("#main-svg")
            .attr("viewBox", `0 0 1200 600`)
            .attr("preserveAspectRatio", "xMidYMid meet");

        Promise.all([
            d3.csv("state_percents.csv"),
            d3.json("https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json")
        ]).then(([csvData, geojson]) => {
            const stateData = {};
            csvData.forEach(d => {
                stateData[d.state] = +d["US Civil War"];
            });

            geojson.features.forEach(feature => {
                const stateName = feature.properties.name;
                feature.properties.percent = stateData[stateName] || 0;
            });

            function updateDimensions() {
                const width = svgContainer.clientWidth;
                const height = svgContainer.clientHeight;
                
                // Recalculate the projection based on actual container size
                const projection = d3.geoAlbersUsa()
                    .translate([width / 2, height / 2])
                    .scale(Math.min(width, height) * 0.95); // Adjust scale to avoid overflow

                const pathGenerator = d3.geoPath().projection(projection);

                let stateFeatures = geojson.features.filter(d => d.properties.name !== "Puerto Rico");

                const regions = {
                    northeast: ["Connecticut", "Maine", "Massachusetts", "New Hampshire", "New Jersey", "New York", "Pennsylvania", "Rhode Island", "Vermont"],
                    south: ["Alabama", "Arkansas", "Delaware", "Florida", "Georgia", "Kentucky", "Louisiana", "Maryland", "Mississippi", "North Carolina", "Oklahoma", "South Carolina", "Tennessee", "Texas", "Virginia", "West Virginia"],
                    midwest: ["Illinois", "Indiana", "Iowa", "Kansas", "Michigan", "Minnesota", "Missouri", "Nebraska", "North Dakota", "Ohio", "South Dakota", "Wisconsin"],
                    west: ["Alaska", "Arizona", "California", "Colorado", "Hawaii", "Idaho", "Montana", "Nevada", "New Mexico", "Oregon", "Utah", "Washington", "Wyoming"]
                };

                const rows = [10, 16, 25];
                const rowYPositions = [height * 0.2, height * 0.5, height * 0.8];
                const scaleFactors = [1.8, 1.0, 0.6];

                stateFeatures.forEach((d, i) => {
                    let rowIndex = 0;
                    if (i >= rows[0]) rowIndex = 1;
                    if (i >= rows[0] + rows[1]) rowIndex = 2;

                    const numColumns = rows[rowIndex];
                    const rowWidth = width * 0.95; // Make it responsive to container width
                    const spacingX = rowWidth / numColumns; // Calculate horizontal spacing
                    const leftMargin = (width - rowWidth) / 2;

                    d.targetX = leftMargin + (i % numColumns) * spacingX + (spacingX / 2);
                    d.targetY = rowYPositions[rowIndex];

                    const bounds = pathGenerator.bounds(d);
                    const stateWidth = bounds[1][0] - bounds[0][0];
                    const stateHeight = bounds[1][1] - bounds[0][1];

                    if (stateWidth > 0 && stateHeight > 0) {
                        const widthScale = (spacingX * 0.9) / stateWidth;
                        const heightScale = (60 * scaleFactors[rowIndex]) / stateHeight;
                        d.scaleFactor = Math.min(widthScale, heightScale);
                    } else {
                        d.scaleFactor = 1;
                    }

                    const centroid = pathGenerator.centroid(d);
                    d.translateX = d.targetX - centroid[0] * d.scaleFactor;
                    d.translateY = d.targetY - centroid[1] * d.scaleFactor;
                });

                const states = svg.selectAll("path")
                    .data(stateFeatures)
                    .join("path")
                    .attr("d", pathGenerator)
                    .attr("fill", d => {
                        if (regions.northeast.includes(d.properties.name)) return "#009076";
                        if (regions.south.includes(d.properties.name)) return "#c71e1d";
                        if (regions.midwest.includes(d.properties.name)) return "#16a1cd";
                        if (regions.west.includes(d.properties.name)) return "#ffd55c";
                        return "#ddd";
                    })
                    .attr("stroke", "black")
                    .attr("stroke-width", 1.5)
                    .attr("vector-effect", "non-scaling-stroke")
                    .attr("transform", d => `translate(${d.translateX}, ${d.translateY}) scale(${d.scaleFactor})`);

                // Tooltip functionality
                states.on("mouseover", (event, d) => {
                        d3.select("#tooltip")
                            .style("opacity", 1)
                            .html(`<strong>${d.properties.name}</strong><br/>Civil War: ${d.properties.percent}%`);
                    })
                    .on("mousemove", event => {
                        d3.select("#tooltip")
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 20) + "px");
                    })
                    .on("mouseout", () => {
                        d3.select("#tooltip")
                            .style("opacity", 0);
                    });
            }

            // Initial rendering
            updateDimensions();

            // Adjust on window resize
            window.addEventListener("resize", updateDimensions);
        });
    </script>
</body>
</html>
